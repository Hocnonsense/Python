"""
    给定一个部分填充的9×9二维数组，目标是用数字1到9填充一个9×9的正方形网格，使每一行、每一列以及9个子网格中的每一个子网格都包含所有的数字。
    这可以通过回溯来解决，类似于n-queens。
    我们检查一个单元格是否安全，然后递归调用下一列上的函数，看看它是否返回True。
    如果是的话，我们已经解决了这个难题。
    否则，我们将回溯并在该单元格中放置另一个数字，并重复此过程。
"""

数独示例 = [    # 这是一个有解的数独
    [3, 0, 6, 5, 0, 8, 4, 0, 0],
    [5, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 8, 7, 0, 0, 0, 0, 3, 1],
    [0, 0, 3, 0, 1, 0, 0, 8, 0],
    [9, 0, 0, 8, 6, 3, 0, 0, 5],
    [0, 5, 0, 0, 9, 0, 6, 0, 0],
    [1, 3, 0, 0, 0, 0, 2, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 7, 4],
    [0, 0, 5, 2, 0, 6, 3, 0, 0],
]
无解数独示例 = [ # 这是一个无解的数独
    [5, 0, 6, 5, 0, 8, 4, 0, 3],
    [5, 2, 0, 0, 0, 0, 0, 0, 2],
    [1, 8, 7, 0, 0, 0, 0, 3, 1],
    [0, 0, 3, 0, 1, 0, 0, 8, 0],
    [9, 0, 0, 8, 6, 3, 0, 0, 5],
    [0, 5, 0, 0, 9, 0, 6, 0, 0],
    [1, 3, 0, 0, 0, 0, 2, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 7, 4],
    [0, 0, 5, 2, 0, 6, 3, 0, 0],
]


def 不重复(网格, 行, 列, n):
    """
        这个函数检查网格，看看每一行、每一列和3x3子网格是否包含数字“n”。
        如果它不是“安全的”(找到一个重复的数字)，则返回False;
        如果它是“安全的”，则返回True
    """

    for i in range(9):
        if 网格[行][i] == n or 网格[i][列] == n:
            return False

    for i in range(3):
        for j in range(3):
            if 网格[(行 - 行 % 3) + i][(列 - 列 % 3) + j] == n:
                return False

    return True


def 填充完(网格):
    """
        这个函数检查数独是否完成。
        当所有单元格都被分配了非零的数字 (并且在任何列、行或3x3子网格中都没有重复的数字时), 它就完成了。
    """

    for 行 in 网格:
        for 小格 in 行:
            if 小格 == 0:
                return False

    return True


def find_empty_location(网格):
    """
        这个函数找到一个空位置，这样我们就可以为特定的行和列分配一个数字。
    """

    for i in range(9):
        for j in range(9):
            if 网格[i][j] == 0:
                return i, j


def 数独(网格):
    """
    接受部分填充的网格，并尝试以这种方式为所有未分配的位置分配值，以满足数独解决方案的要求(行、列和框之间不重复)

    >>> 数独(数独示例)  # doctest: +NORMALIZE_WHITESPACE
    [[3, 1, 6, 5, 7, 8, 4, 9, 2],
     [5, 2, 9, 1, 3, 4, 7, 6, 8],
     [4, 8, 7, 6, 2, 9, 5, 3, 1],
     [2, 6, 3, 4, 1, 5, 9, 8, 7],
     [9, 7, 4, 8, 6, 3, 1, 2, 5],
     [8, 5, 1, 7, 9, 2, 6, 4, 3],
     [1, 3, 8, 9, 4, 7, 2, 5, 6],
     [6, 9, 2, 3, 5, 1, 8, 7, 4],
     [7, 4, 5, 2, 8, 6, 3, 1, 9]]
     >>> 数独(无解数独示例)
     False
     """

    if 填充完(网格):
        return 网格

    行, 列 = find_empty_location(网格)

    for 数字 in range(1, 10):
        if 不重复(网格, 行, 列, 数字):
            网格[行][列] = 数字

            if 数独(网格) != False:
                return 网格
            else:
                网格[行][列] = 0

    return False


def 显示答案(答案):
    """
    A function to print the 答案 in the form
    of a 9x9 网格

    """
    if 答案:
        print("数独答案:")
        for 行 in 网格:
            for 小格 in 行:
                print(小格, end=" ")
            print()
    else:
        print("这个数独无解.")


if __name__ == "__main__":

    # make a copy of 网格 so that you can compare with the unmodified 网格
    for 网格 in (数独示例, 无解数独示例):
        网格 = list(map(list, 网格))
        答案 = 数独(网格)
        显示答案(答案)