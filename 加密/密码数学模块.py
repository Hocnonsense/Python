def 最小公约数(a, b):
    """
        使用辗转相除法, 取最小公约数
        默认 a<b
    """
    while a != 0:
        a, b = b % a, a
    return b
gcd = 最小公约数

def 求模逆(a, m):
    """
        计算e对于φ(n)的模反元素d,所谓"模反元素"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。
                ed ≡ 1 (mod φ(n))
        这个式子等价于
                ed - 1 = kφ(n)
        那么选定e后，是否可以利用凑数法去凑出来等式：
                ed - 1 = kφ(n) 
            的解？找到k，即 
                for k from 0 increase，judge [(kφ(n) + 1) % e ] == 0 
            是否成立，当它成立的时候，就找到了k，然后通过（kφ(n)+1）% e 得到模逆元d，这个与通过辗转相除法求模逆元好理解的多。
        但是对于选定了e之后，等式
                ed - 1 = kφ(n) 
            的k解是否是唯一的？ 若是不是唯一的，这个方法就出现了漏洞，他仅仅是找到第一个使式子成立的k就结束了。
        但是反过来讲，若k不唯一，那么d也将是不唯一的，这样会出现对于一个公钥e，私钥d是不唯一的？？？
        虽然我没有仔细去研究RSA算法的证明，但我觉得对于一个既定公钥e，与之对应的私钥d必定要是唯一的~~~欢迎补充  证明 >_<
        ————————————————
        版权声明：本文为CSDN博主「IOT2017」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
        原文链接：https://blog.csdn.net/IOT2017/article/details/84069882
    """
    if 最小公约数(a, m) != 1:
        return None
    else:
        # @Haor: delete 'u2' and 'v2'
        u1, u3 = 1, a                                               # u1, u2, u3 = 1, 0, a
        v1, v3 = 0, m                                               # v1, v2, v3 = 0, 1, m
        while v3 != 0:
            q = u3 // v3
            v1, v3, u1, u3 = (u1 - q * v1), (u3 - q *v3), v1, v3    # v1, v2, v3, u1, u2, u3 = (u1-q*v1), (u2-q*v2), (u3-q*v3), v1, v2, v3
        return u1 % m
